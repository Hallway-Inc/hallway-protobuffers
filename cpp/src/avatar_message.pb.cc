// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: avatar_message.proto

#include "avatar_message.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr AvatarPredictionMessage::AvatarPredictionMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : blendshapes_(nullptr)
  , rotation_(nullptr)
  , transform_(nullptr){}
struct AvatarPredictionMessageDefaultTypeInternal {
  constexpr AvatarPredictionMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AvatarPredictionMessageDefaultTypeInternal() {}
  union {
    AvatarPredictionMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AvatarPredictionMessageDefaultTypeInternal _AvatarPredictionMessage_default_instance_;
constexpr BlendShapes::BlendShapes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : browdown_l_(0)
  , browdown_r_(0)
  , browinnerup_(0)
  , browouterup_l_(0)
  , browouterup_r_(0)
  , cheeksquint_l_(0)
  , cheeksquint_r_(0)
  , eyeblink_l_(0)
  , eyeblink_r_(0)
  , eyelookdown_l_(0)
  , eyelookdown_r_(0)
  , eyelookin_l_(0)
  , eyelookin_r_(0)
  , eyelookout_l_(0)
  , eyelookout_r_(0)
  , eyelookup_l_(0)
  , eyelookup_r_(0)
  , eyesquint_l_(0)
  , eyesquint_r_(0)
  , eyewide_l_(0)
  , eyewide_r_(0)
  , jawleft_(0)
  , jawopen_(0)
  , jawright_(0)
  , mouthclose_(0)
  , mouthdimple_l_(0)
  , mouthdimple_r_(0)
  , mouthfrown_l_(0)
  , mouthfrown_r_(0)
  , mouthfunnel_(0)
  , mouthleft_(0)
  , mouthlowerdown_l_(0)
  , mouthlowerdown_r_(0)
  , mouthpress_l_(0)
  , mouthpress_r_(0)
  , mouthpucker_(0)
  , mouthright_(0)
  , mouthrolllower_(0)
  , mouthrollupper_(0)
  , mouthshruglower_(0)
  , mouthshrugupper_(0)
  , mouthsmile_l_(0)
  , mouthsmile_r_(0)
  , mouthstretch_l_(0)
  , mouthstretch_r_(0)
  , mouthupperup_l_(0)
  , mouthupperup_r_(0)
  , nosesneer_l_(0)
  , nosesneer_r_(0)
  , cheekpuff_(0)
  , jawforward_(0)
  , tongueout_(0){}
struct BlendShapesDefaultTypeInternal {
  constexpr BlendShapesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BlendShapesDefaultTypeInternal() {}
  union {
    BlendShapes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BlendShapesDefaultTypeInternal _BlendShapes_default_instance_;
constexpr Rotation::Rotation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pitch_(0)
  , roll_(0)
  , yaw_(0){}
struct RotationDefaultTypeInternal {
  constexpr RotationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RotationDefaultTypeInternal() {}
  union {
    Rotation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RotationDefaultTypeInternal _Rotation_default_instance_;
constexpr Transform::Transform(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_(0)
  , y_(0)
  , z_(0){}
struct TransformDefaultTypeInternal {
  constexpr TransformDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransformDefaultTypeInternal() {}
  union {
    Transform _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransformDefaultTypeInternal _Transform_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_avatar_5fmessage_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_avatar_5fmessage_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_avatar_5fmessage_2eproto = nullptr;

const uint32_t TableStruct_avatar_5fmessage_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AvatarPredictionMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AvatarPredictionMessage, blendshapes_),
  PROTOBUF_FIELD_OFFSET(::AvatarPredictionMessage, rotation_),
  PROTOBUF_FIELD_OFFSET(::AvatarPredictionMessage, transform_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::BlendShapes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BlendShapes, browdown_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, browdown_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, browinnerup_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, browouterup_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, browouterup_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, cheeksquint_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, cheeksquint_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyeblink_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyeblink_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookdown_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookdown_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookin_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookin_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookout_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookout_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookup_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyelookup_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyesquint_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyesquint_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyewide_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, eyewide_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, jawleft_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, jawopen_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, jawright_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthclose_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthdimple_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthdimple_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthfrown_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthfrown_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthfunnel_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthleft_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthlowerdown_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthlowerdown_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthpress_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthpress_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthpucker_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthright_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthrolllower_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthrollupper_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthshruglower_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthshrugupper_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthsmile_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthsmile_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthstretch_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthstretch_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthupperup_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, mouthupperup_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, nosesneer_l_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, nosesneer_r_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, cheekpuff_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, jawforward_),
  PROTOBUF_FIELD_OFFSET(::BlendShapes, tongueout_),
  PROTOBUF_FIELD_OFFSET(::Rotation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Rotation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Rotation, pitch_),
  PROTOBUF_FIELD_OFFSET(::Rotation, roll_),
  PROTOBUF_FIELD_OFFSET(::Rotation, yaw_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::Transform, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Transform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Transform, x_),
  PROTOBUF_FIELD_OFFSET(::Transform, y_),
  PROTOBUF_FIELD_OFFSET(::Transform, z_),
  0,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::AvatarPredictionMessage)},
  { 9, -1, -1, sizeof(::BlendShapes)},
  { 67, 76, -1, sizeof(::Rotation)},
  { 79, 88, -1, sizeof(::Transform)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AvatarPredictionMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_BlendShapes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Rotation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Transform_default_instance_),
};

const char descriptor_table_protodef_avatar_5fmessage_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024avatar_message.proto\"\232\001\n\027AvatarPredict"
  "ionMessage\022.\n\013blendShapes\030\001 \001(\0132\014.BlendS"
  "hapesR\013blendShapes\022%\n\010rotation\030\002 \001(\0132\t.R"
  "otationR\010rotation\022(\n\ttransform\030\003 \001(\0132\n.T"
  "ransformR\ttransform\"\221\016\n\013BlendShapes\022\035\n\nb"
  "rowDown_L\030\001 \001(\002R\tbrowDownL\022\035\n\nbrowDown_R"
  "\030\002 \001(\002R\tbrowDownR\022 \n\013browInnerUp\030\003 \001(\002R\013"
  "browInnerUp\022#\n\rbrowOuterUp_L\030\004 \001(\002R\014brow"
  "OuterUpL\022#\n\rbrowOuterUp_R\030\005 \001(\002R\014browOut"
  "erUpR\022#\n\rcheekSquint_L\030\006 \001(\002R\014cheekSquin"
  "tL\022#\n\rcheekSquint_R\030\007 \001(\002R\014cheekSquintR\022"
  "\035\n\neyeBlink_L\030\010 \001(\002R\teyeBlinkL\022\035\n\neyeBli"
  "nk_R\030\t \001(\002R\teyeBlinkR\022#\n\reyeLookDown_L\030\n"
  " \001(\002R\014eyeLookDownL\022#\n\reyeLookDown_R\030\013 \001("
  "\002R\014eyeLookDownR\022\037\n\013eyeLookIn_L\030\014 \001(\002R\ney"
  "eLookInL\022\037\n\013eyeLookIn_R\030\r \001(\002R\neyeLookIn"
  "R\022!\n\014eyeLookOut_L\030\016 \001(\002R\013eyeLookOutL\022!\n\014"
  "eyeLookOut_R\030\017 \001(\002R\013eyeLookOutR\022\037\n\013eyeLo"
  "okUp_L\030\020 \001(\002R\neyeLookUpL\022\037\n\013eyeLookUp_R\030"
  "\021 \001(\002R\neyeLookUpR\022\037\n\013eyeSquint_L\030\022 \001(\002R\n"
  "eyeSquintL\022\037\n\013eyeSquint_R\030\023 \001(\002R\neyeSqui"
  "ntR\022\033\n\teyeWide_L\030\024 \001(\002R\010eyeWideL\022\033\n\teyeW"
  "ide_R\030\025 \001(\002R\010eyeWideR\022\030\n\007jawLeft\030\026 \001(\002R\007"
  "jawLeft\022\030\n\007jawOpen\030\027 \001(\002R\007jawOpen\022\032\n\010jaw"
  "Right\030\030 \001(\002R\010jawRight\022\036\n\nmouthClose\030\031 \001("
  "\002R\nmouthClose\022#\n\rmouthDimple_L\030\032 \001(\002R\014mo"
  "uthDimpleL\022#\n\rmouthDimple_R\030\033 \001(\002R\014mouth"
  "DimpleR\022!\n\014mouthFrown_L\030\034 \001(\002R\013mouthFrow"
  "nL\022!\n\014mouthFrown_R\030\035 \001(\002R\013mouthFrownR\022 \n"
  "\013mouthFunnel\030\036 \001(\002R\013mouthFunnel\022\034\n\tmouth"
  "Left\030\037 \001(\002R\tmouthLeft\022)\n\020mouthLowerDown_"
  "L\030  \001(\002R\017mouthLowerDownL\022)\n\020mouthLowerDo"
  "wn_R\030! \001(\002R\017mouthLowerDownR\022!\n\014mouthPres"
  "s_L\030\" \001(\002R\013mouthPressL\022!\n\014mouthPress_R\030#"
  " \001(\002R\013mouthPressR\022 \n\013mouthPucker\030$ \001(\002R\013"
  "mouthPucker\022\036\n\nmouthRight\030% \001(\002R\nmouthRi"
  "ght\022&\n\016mouthRollLower\030& \001(\002R\016mouthRollLo"
  "wer\022&\n\016mouthRollUpper\030\' \001(\002R\016mouthRollUp"
  "per\022(\n\017mouthShrugLower\030( \001(\002R\017mouthShrug"
  "Lower\022(\n\017mouthShrugUpper\030) \001(\002R\017mouthShr"
  "ugUpper\022!\n\014mouthSmile_L\030* \001(\002R\013mouthSmil"
  "eL\022!\n\014mouthSmile_R\030+ \001(\002R\013mouthSmileR\022%\n"
  "\016mouthStretch_L\030, \001(\002R\rmouthStretchL\022%\n\016"
  "mouthStretch_R\030- \001(\002R\rmouthStretchR\022%\n\016m"
  "outhUpperUp_L\030. \001(\002R\rmouthUpperUpL\022%\n\016mo"
  "uthUpperUp_R\030/ \001(\002R\rmouthUpperUpR\022\037\n\013nos"
  "eSneer_L\0300 \001(\002R\nnoseSneerL\022\037\n\013noseSneer_"
  "R\0301 \001(\002R\nnoseSneerR\022\034\n\tcheekPuff\0302 \001(\002R\t"
  "cheekPuff\022\036\n\njawForward\0303 \001(\002R\njawForwar"
  "d\022\034\n\ttongueOut\0304 \001(\002R\ttongueOut\"p\n\010Rotat"
  "ion\022\031\n\005pitch\030\001 \001(\002H\000R\005pitch\210\001\001\022\027\n\004roll\030\002"
  " \001(\002H\001R\004roll\210\001\001\022\025\n\003yaw\030\003 \001(\002H\002R\003yaw\210\001\001B\010"
  "\n\006_pitchB\007\n\005_rollB\006\n\004_yaw\"V\n\tTransform\022\021"
  "\n\001x\030\001 \001(\002H\000R\001x\210\001\001\022\021\n\001y\030\002 \001(\002H\001R\001y\210\001\001\022\021\n\001"
  "z\030\003 \001(\002H\002R\001z\210\001\001B\004\n\002_xB\004\n\002_yB\004\n\002_zb\006proto"
  "3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_avatar_5fmessage_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_avatar_5fmessage_2eproto = {
  false, false, 2201, descriptor_table_protodef_avatar_5fmessage_2eproto, "avatar_message.proto", 
  &descriptor_table_avatar_5fmessage_2eproto_once, nullptr, 0, 4,
  schemas, file_default_instances, TableStruct_avatar_5fmessage_2eproto::offsets,
  file_level_metadata_avatar_5fmessage_2eproto, file_level_enum_descriptors_avatar_5fmessage_2eproto, file_level_service_descriptors_avatar_5fmessage_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_avatar_5fmessage_2eproto_getter() {
  return &descriptor_table_avatar_5fmessage_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_avatar_5fmessage_2eproto(&descriptor_table_avatar_5fmessage_2eproto);

// ===================================================================

class AvatarPredictionMessage::_Internal {
 public:
  static const ::BlendShapes& blendshapes(const AvatarPredictionMessage* msg);
  static const ::Rotation& rotation(const AvatarPredictionMessage* msg);
  static const ::Transform& transform(const AvatarPredictionMessage* msg);
};

const ::BlendShapes&
AvatarPredictionMessage::_Internal::blendshapes(const AvatarPredictionMessage* msg) {
  return *msg->blendshapes_;
}
const ::Rotation&
AvatarPredictionMessage::_Internal::rotation(const AvatarPredictionMessage* msg) {
  return *msg->rotation_;
}
const ::Transform&
AvatarPredictionMessage::_Internal::transform(const AvatarPredictionMessage* msg) {
  return *msg->transform_;
}
AvatarPredictionMessage::AvatarPredictionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AvatarPredictionMessage)
}
AvatarPredictionMessage::AvatarPredictionMessage(const AvatarPredictionMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_blendshapes()) {
    blendshapes_ = new ::BlendShapes(*from.blendshapes_);
  } else {
    blendshapes_ = nullptr;
  }
  if (from._internal_has_rotation()) {
    rotation_ = new ::Rotation(*from.rotation_);
  } else {
    rotation_ = nullptr;
  }
  if (from._internal_has_transform()) {
    transform_ = new ::Transform(*from.transform_);
  } else {
    transform_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AvatarPredictionMessage)
}

inline void AvatarPredictionMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&blendshapes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&transform_) -
    reinterpret_cast<char*>(&blendshapes_)) + sizeof(transform_));
}

AvatarPredictionMessage::~AvatarPredictionMessage() {
  // @@protoc_insertion_point(destructor:AvatarPredictionMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AvatarPredictionMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete blendshapes_;
  if (this != internal_default_instance()) delete rotation_;
  if (this != internal_default_instance()) delete transform_;
}

void AvatarPredictionMessage::ArenaDtor(void* object) {
  AvatarPredictionMessage* _this = reinterpret_cast< AvatarPredictionMessage* >(object);
  (void)_this;
}
void AvatarPredictionMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AvatarPredictionMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AvatarPredictionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:AvatarPredictionMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && blendshapes_ != nullptr) {
    delete blendshapes_;
  }
  blendshapes_ = nullptr;
  if (GetArenaForAllocation() == nullptr && rotation_ != nullptr) {
    delete rotation_;
  }
  rotation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AvatarPredictionMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .BlendShapes blendShapes = 1 [json_name = "blendShapes"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_blendshapes(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Rotation rotation = 2 [json_name = "rotation"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Transform transform = 3 [json_name = "transform"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_transform(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AvatarPredictionMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AvatarPredictionMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .BlendShapes blendShapes = 1 [json_name = "blendShapes"];
  if (this->_internal_has_blendshapes()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::blendshapes(this), target, stream);
  }

  // .Rotation rotation = 2 [json_name = "rotation"];
  if (this->_internal_has_rotation()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::rotation(this), target, stream);
  }

  // .Transform transform = 3 [json_name = "transform"];
  if (this->_internal_has_transform()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::transform(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AvatarPredictionMessage)
  return target;
}

size_t AvatarPredictionMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AvatarPredictionMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .BlendShapes blendShapes = 1 [json_name = "blendShapes"];
  if (this->_internal_has_blendshapes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *blendshapes_);
  }

  // .Rotation rotation = 2 [json_name = "rotation"];
  if (this->_internal_has_rotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *rotation_);
  }

  // .Transform transform = 3 [json_name = "transform"];
  if (this->_internal_has_transform()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *transform_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AvatarPredictionMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AvatarPredictionMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AvatarPredictionMessage::GetClassData() const { return &_class_data_; }

void AvatarPredictionMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AvatarPredictionMessage *>(to)->MergeFrom(
      static_cast<const AvatarPredictionMessage &>(from));
}


void AvatarPredictionMessage::MergeFrom(const AvatarPredictionMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AvatarPredictionMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_blendshapes()) {
    _internal_mutable_blendshapes()->::BlendShapes::MergeFrom(from._internal_blendshapes());
  }
  if (from._internal_has_rotation()) {
    _internal_mutable_rotation()->::Rotation::MergeFrom(from._internal_rotation());
  }
  if (from._internal_has_transform()) {
    _internal_mutable_transform()->::Transform::MergeFrom(from._internal_transform());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AvatarPredictionMessage::CopyFrom(const AvatarPredictionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AvatarPredictionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvatarPredictionMessage::IsInitialized() const {
  return true;
}

void AvatarPredictionMessage::InternalSwap(AvatarPredictionMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvatarPredictionMessage, transform_)
      + sizeof(AvatarPredictionMessage::transform_)
      - PROTOBUF_FIELD_OFFSET(AvatarPredictionMessage, blendshapes_)>(
          reinterpret_cast<char*>(&blendshapes_),
          reinterpret_cast<char*>(&other->blendshapes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AvatarPredictionMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_avatar_5fmessage_2eproto_getter, &descriptor_table_avatar_5fmessage_2eproto_once,
      file_level_metadata_avatar_5fmessage_2eproto[0]);
}

// ===================================================================

class BlendShapes::_Internal {
 public:
};

BlendShapes::BlendShapes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:BlendShapes)
}
BlendShapes::BlendShapes(const BlendShapes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&browdown_l_, &from.browdown_l_,
    static_cast<size_t>(reinterpret_cast<char*>(&tongueout_) -
    reinterpret_cast<char*>(&browdown_l_)) + sizeof(tongueout_));
  // @@protoc_insertion_point(copy_constructor:BlendShapes)
}

inline void BlendShapes::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&browdown_l_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tongueout_) -
    reinterpret_cast<char*>(&browdown_l_)) + sizeof(tongueout_));
}

BlendShapes::~BlendShapes() {
  // @@protoc_insertion_point(destructor:BlendShapes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BlendShapes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BlendShapes::ArenaDtor(void* object) {
  BlendShapes* _this = reinterpret_cast< BlendShapes* >(object);
  (void)_this;
}
void BlendShapes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BlendShapes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BlendShapes::Clear() {
// @@protoc_insertion_point(message_clear_start:BlendShapes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&browdown_l_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tongueout_) -
      reinterpret_cast<char*>(&browdown_l_)) + sizeof(tongueout_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlendShapes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float browDown_L = 1 [json_name = "browDownL"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          browdown_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float browDown_R = 2 [json_name = "browDownR"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          browdown_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float browInnerUp = 3 [json_name = "browInnerUp"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          browinnerup_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float browOuterUp_L = 4 [json_name = "browOuterUpL"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          browouterup_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float browOuterUp_R = 5 [json_name = "browOuterUpR"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          browouterup_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float cheekSquint_L = 6 [json_name = "cheekSquintL"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          cheeksquint_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float cheekSquint_R = 7 [json_name = "cheekSquintR"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          cheeksquint_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeBlink_L = 8 [json_name = "eyeBlinkL"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          eyeblink_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeBlink_R = 9 [json_name = "eyeBlinkR"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          eyeblink_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookDown_L = 10 [json_name = "eyeLookDownL"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          eyelookdown_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookDown_R = 11 [json_name = "eyeLookDownR"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          eyelookdown_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookIn_L = 12 [json_name = "eyeLookInL"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          eyelookin_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookIn_R = 13 [json_name = "eyeLookInR"];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          eyelookin_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookOut_L = 14 [json_name = "eyeLookOutL"];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          eyelookout_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookOut_R = 15 [json_name = "eyeLookOutR"];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          eyelookout_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookUp_L = 16 [json_name = "eyeLookUpL"];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          eyelookup_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeLookUp_R = 17 [json_name = "eyeLookUpR"];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          eyelookup_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeSquint_L = 18 [json_name = "eyeSquintL"];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          eyesquint_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeSquint_R = 19 [json_name = "eyeSquintR"];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          eyesquint_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeWide_L = 20 [json_name = "eyeWideL"];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          eyewide_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float eyeWide_R = 21 [json_name = "eyeWideR"];
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          eyewide_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float jawLeft = 22 [json_name = "jawLeft"];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          jawleft_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float jawOpen = 23 [json_name = "jawOpen"];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          jawopen_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float jawRight = 24 [json_name = "jawRight"];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          jawright_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthClose = 25 [json_name = "mouthClose"];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          mouthclose_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthDimple_L = 26 [json_name = "mouthDimpleL"];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 213)) {
          mouthdimple_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthDimple_R = 27 [json_name = "mouthDimpleR"];
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 221)) {
          mouthdimple_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthFrown_L = 28 [json_name = "mouthFrownL"];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 229)) {
          mouthfrown_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthFrown_R = 29 [json_name = "mouthFrownR"];
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 237)) {
          mouthfrown_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthFunnel = 30 [json_name = "mouthFunnel"];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 245)) {
          mouthfunnel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthLeft = 31 [json_name = "mouthLeft"];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 253)) {
          mouthleft_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthLowerDown_L = 32 [json_name = "mouthLowerDownL"];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          mouthlowerdown_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthLowerDown_R = 33 [json_name = "mouthLowerDownR"];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          mouthlowerdown_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthPress_L = 34 [json_name = "mouthPressL"];
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          mouthpress_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthPress_R = 35 [json_name = "mouthPressR"];
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          mouthpress_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthPucker = 36 [json_name = "mouthPucker"];
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          mouthpucker_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthRight = 37 [json_name = "mouthRight"];
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          mouthright_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthRollLower = 38 [json_name = "mouthRollLower"];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          mouthrolllower_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthRollUpper = 39 [json_name = "mouthRollUpper"];
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          mouthrollupper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthShrugLower = 40 [json_name = "mouthShrugLower"];
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          mouthshruglower_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthShrugUpper = 41 [json_name = "mouthShrugUpper"];
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          mouthshrugupper_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthSmile_L = 42 [json_name = "mouthSmileL"];
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          mouthsmile_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthSmile_R = 43 [json_name = "mouthSmileR"];
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          mouthsmile_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthStretch_L = 44 [json_name = "mouthStretchL"];
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          mouthstretch_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthStretch_R = 45 [json_name = "mouthStretchR"];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          mouthstretch_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthUpperUp_L = 46 [json_name = "mouthUpperUpL"];
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          mouthupperup_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float mouthUpperUp_R = 47 [json_name = "mouthUpperUpR"];
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          mouthupperup_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float noseSneer_L = 48 [json_name = "noseSneerL"];
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          nosesneer_l_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float noseSneer_R = 49 [json_name = "noseSneerR"];
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          nosesneer_r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float cheekPuff = 50 [json_name = "cheekPuff"];
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          cheekpuff_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float jawForward = 51 [json_name = "jawForward"];
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          jawforward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float tongueOut = 52 [json_name = "tongueOut"];
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          tongueout_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlendShapes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BlendShapes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float browDown_L = 1 [json_name = "browDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_l = this->_internal_browdown_l();
  uint32_t raw_browdown_l;
  memcpy(&raw_browdown_l, &tmp_browdown_l, sizeof(tmp_browdown_l));
  if (raw_browdown_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_browdown_l(), target);
  }

  // float browDown_R = 2 [json_name = "browDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_r = this->_internal_browdown_r();
  uint32_t raw_browdown_r;
  memcpy(&raw_browdown_r, &tmp_browdown_r, sizeof(tmp_browdown_r));
  if (raw_browdown_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_browdown_r(), target);
  }

  // float browInnerUp = 3 [json_name = "browInnerUp"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browinnerup = this->_internal_browinnerup();
  uint32_t raw_browinnerup;
  memcpy(&raw_browinnerup, &tmp_browinnerup, sizeof(tmp_browinnerup));
  if (raw_browinnerup != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_browinnerup(), target);
  }

  // float browOuterUp_L = 4 [json_name = "browOuterUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_l = this->_internal_browouterup_l();
  uint32_t raw_browouterup_l;
  memcpy(&raw_browouterup_l, &tmp_browouterup_l, sizeof(tmp_browouterup_l));
  if (raw_browouterup_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_browouterup_l(), target);
  }

  // float browOuterUp_R = 5 [json_name = "browOuterUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_r = this->_internal_browouterup_r();
  uint32_t raw_browouterup_r;
  memcpy(&raw_browouterup_r, &tmp_browouterup_r, sizeof(tmp_browouterup_r));
  if (raw_browouterup_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_browouterup_r(), target);
  }

  // float cheekSquint_L = 6 [json_name = "cheekSquintL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_l = this->_internal_cheeksquint_l();
  uint32_t raw_cheeksquint_l;
  memcpy(&raw_cheeksquint_l, &tmp_cheeksquint_l, sizeof(tmp_cheeksquint_l));
  if (raw_cheeksquint_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_cheeksquint_l(), target);
  }

  // float cheekSquint_R = 7 [json_name = "cheekSquintR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_r = this->_internal_cheeksquint_r();
  uint32_t raw_cheeksquint_r;
  memcpy(&raw_cheeksquint_r, &tmp_cheeksquint_r, sizeof(tmp_cheeksquint_r));
  if (raw_cheeksquint_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_cheeksquint_r(), target);
  }

  // float eyeBlink_L = 8 [json_name = "eyeBlinkL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_l = this->_internal_eyeblink_l();
  uint32_t raw_eyeblink_l;
  memcpy(&raw_eyeblink_l, &tmp_eyeblink_l, sizeof(tmp_eyeblink_l));
  if (raw_eyeblink_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_eyeblink_l(), target);
  }

  // float eyeBlink_R = 9 [json_name = "eyeBlinkR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_r = this->_internal_eyeblink_r();
  uint32_t raw_eyeblink_r;
  memcpy(&raw_eyeblink_r, &tmp_eyeblink_r, sizeof(tmp_eyeblink_r));
  if (raw_eyeblink_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_eyeblink_r(), target);
  }

  // float eyeLookDown_L = 10 [json_name = "eyeLookDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_l = this->_internal_eyelookdown_l();
  uint32_t raw_eyelookdown_l;
  memcpy(&raw_eyelookdown_l, &tmp_eyelookdown_l, sizeof(tmp_eyelookdown_l));
  if (raw_eyelookdown_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_eyelookdown_l(), target);
  }

  // float eyeLookDown_R = 11 [json_name = "eyeLookDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_r = this->_internal_eyelookdown_r();
  uint32_t raw_eyelookdown_r;
  memcpy(&raw_eyelookdown_r, &tmp_eyelookdown_r, sizeof(tmp_eyelookdown_r));
  if (raw_eyelookdown_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_eyelookdown_r(), target);
  }

  // float eyeLookIn_L = 12 [json_name = "eyeLookInL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_l = this->_internal_eyelookin_l();
  uint32_t raw_eyelookin_l;
  memcpy(&raw_eyelookin_l, &tmp_eyelookin_l, sizeof(tmp_eyelookin_l));
  if (raw_eyelookin_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_eyelookin_l(), target);
  }

  // float eyeLookIn_R = 13 [json_name = "eyeLookInR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_r = this->_internal_eyelookin_r();
  uint32_t raw_eyelookin_r;
  memcpy(&raw_eyelookin_r, &tmp_eyelookin_r, sizeof(tmp_eyelookin_r));
  if (raw_eyelookin_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_eyelookin_r(), target);
  }

  // float eyeLookOut_L = 14 [json_name = "eyeLookOutL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_l = this->_internal_eyelookout_l();
  uint32_t raw_eyelookout_l;
  memcpy(&raw_eyelookout_l, &tmp_eyelookout_l, sizeof(tmp_eyelookout_l));
  if (raw_eyelookout_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_eyelookout_l(), target);
  }

  // float eyeLookOut_R = 15 [json_name = "eyeLookOutR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_r = this->_internal_eyelookout_r();
  uint32_t raw_eyelookout_r;
  memcpy(&raw_eyelookout_r, &tmp_eyelookout_r, sizeof(tmp_eyelookout_r));
  if (raw_eyelookout_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_eyelookout_r(), target);
  }

  // float eyeLookUp_L = 16 [json_name = "eyeLookUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_l = this->_internal_eyelookup_l();
  uint32_t raw_eyelookup_l;
  memcpy(&raw_eyelookup_l, &tmp_eyelookup_l, sizeof(tmp_eyelookup_l));
  if (raw_eyelookup_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_eyelookup_l(), target);
  }

  // float eyeLookUp_R = 17 [json_name = "eyeLookUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_r = this->_internal_eyelookup_r();
  uint32_t raw_eyelookup_r;
  memcpy(&raw_eyelookup_r, &tmp_eyelookup_r, sizeof(tmp_eyelookup_r));
  if (raw_eyelookup_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_eyelookup_r(), target);
  }

  // float eyeSquint_L = 18 [json_name = "eyeSquintL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_l = this->_internal_eyesquint_l();
  uint32_t raw_eyesquint_l;
  memcpy(&raw_eyesquint_l, &tmp_eyesquint_l, sizeof(tmp_eyesquint_l));
  if (raw_eyesquint_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_eyesquint_l(), target);
  }

  // float eyeSquint_R = 19 [json_name = "eyeSquintR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_r = this->_internal_eyesquint_r();
  uint32_t raw_eyesquint_r;
  memcpy(&raw_eyesquint_r, &tmp_eyesquint_r, sizeof(tmp_eyesquint_r));
  if (raw_eyesquint_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_eyesquint_r(), target);
  }

  // float eyeWide_L = 20 [json_name = "eyeWideL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_l = this->_internal_eyewide_l();
  uint32_t raw_eyewide_l;
  memcpy(&raw_eyewide_l, &tmp_eyewide_l, sizeof(tmp_eyewide_l));
  if (raw_eyewide_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(20, this->_internal_eyewide_l(), target);
  }

  // float eyeWide_R = 21 [json_name = "eyeWideR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_r = this->_internal_eyewide_r();
  uint32_t raw_eyewide_r;
  memcpy(&raw_eyewide_r, &tmp_eyewide_r, sizeof(tmp_eyewide_r));
  if (raw_eyewide_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_eyewide_r(), target);
  }

  // float jawLeft = 22 [json_name = "jawLeft"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawleft = this->_internal_jawleft();
  uint32_t raw_jawleft;
  memcpy(&raw_jawleft, &tmp_jawleft, sizeof(tmp_jawleft));
  if (raw_jawleft != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(22, this->_internal_jawleft(), target);
  }

  // float jawOpen = 23 [json_name = "jawOpen"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawopen = this->_internal_jawopen();
  uint32_t raw_jawopen;
  memcpy(&raw_jawopen, &tmp_jawopen, sizeof(tmp_jawopen));
  if (raw_jawopen != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(23, this->_internal_jawopen(), target);
  }

  // float jawRight = 24 [json_name = "jawRight"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawright = this->_internal_jawright();
  uint32_t raw_jawright;
  memcpy(&raw_jawright, &tmp_jawright, sizeof(tmp_jawright));
  if (raw_jawright != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_jawright(), target);
  }

  // float mouthClose = 25 [json_name = "mouthClose"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthclose = this->_internal_mouthclose();
  uint32_t raw_mouthclose;
  memcpy(&raw_mouthclose, &tmp_mouthclose, sizeof(tmp_mouthclose));
  if (raw_mouthclose != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_mouthclose(), target);
  }

  // float mouthDimple_L = 26 [json_name = "mouthDimpleL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_l = this->_internal_mouthdimple_l();
  uint32_t raw_mouthdimple_l;
  memcpy(&raw_mouthdimple_l, &tmp_mouthdimple_l, sizeof(tmp_mouthdimple_l));
  if (raw_mouthdimple_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(26, this->_internal_mouthdimple_l(), target);
  }

  // float mouthDimple_R = 27 [json_name = "mouthDimpleR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_r = this->_internal_mouthdimple_r();
  uint32_t raw_mouthdimple_r;
  memcpy(&raw_mouthdimple_r, &tmp_mouthdimple_r, sizeof(tmp_mouthdimple_r));
  if (raw_mouthdimple_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(27, this->_internal_mouthdimple_r(), target);
  }

  // float mouthFrown_L = 28 [json_name = "mouthFrownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_l = this->_internal_mouthfrown_l();
  uint32_t raw_mouthfrown_l;
  memcpy(&raw_mouthfrown_l, &tmp_mouthfrown_l, sizeof(tmp_mouthfrown_l));
  if (raw_mouthfrown_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(28, this->_internal_mouthfrown_l(), target);
  }

  // float mouthFrown_R = 29 [json_name = "mouthFrownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_r = this->_internal_mouthfrown_r();
  uint32_t raw_mouthfrown_r;
  memcpy(&raw_mouthfrown_r, &tmp_mouthfrown_r, sizeof(tmp_mouthfrown_r));
  if (raw_mouthfrown_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(29, this->_internal_mouthfrown_r(), target);
  }

  // float mouthFunnel = 30 [json_name = "mouthFunnel"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfunnel = this->_internal_mouthfunnel();
  uint32_t raw_mouthfunnel;
  memcpy(&raw_mouthfunnel, &tmp_mouthfunnel, sizeof(tmp_mouthfunnel));
  if (raw_mouthfunnel != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(30, this->_internal_mouthfunnel(), target);
  }

  // float mouthLeft = 31 [json_name = "mouthLeft"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthleft = this->_internal_mouthleft();
  uint32_t raw_mouthleft;
  memcpy(&raw_mouthleft, &tmp_mouthleft, sizeof(tmp_mouthleft));
  if (raw_mouthleft != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(31, this->_internal_mouthleft(), target);
  }

  // float mouthLowerDown_L = 32 [json_name = "mouthLowerDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_l = this->_internal_mouthlowerdown_l();
  uint32_t raw_mouthlowerdown_l;
  memcpy(&raw_mouthlowerdown_l, &tmp_mouthlowerdown_l, sizeof(tmp_mouthlowerdown_l));
  if (raw_mouthlowerdown_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(32, this->_internal_mouthlowerdown_l(), target);
  }

  // float mouthLowerDown_R = 33 [json_name = "mouthLowerDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_r = this->_internal_mouthlowerdown_r();
  uint32_t raw_mouthlowerdown_r;
  memcpy(&raw_mouthlowerdown_r, &tmp_mouthlowerdown_r, sizeof(tmp_mouthlowerdown_r));
  if (raw_mouthlowerdown_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(33, this->_internal_mouthlowerdown_r(), target);
  }

  // float mouthPress_L = 34 [json_name = "mouthPressL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_l = this->_internal_mouthpress_l();
  uint32_t raw_mouthpress_l;
  memcpy(&raw_mouthpress_l, &tmp_mouthpress_l, sizeof(tmp_mouthpress_l));
  if (raw_mouthpress_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(34, this->_internal_mouthpress_l(), target);
  }

  // float mouthPress_R = 35 [json_name = "mouthPressR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_r = this->_internal_mouthpress_r();
  uint32_t raw_mouthpress_r;
  memcpy(&raw_mouthpress_r, &tmp_mouthpress_r, sizeof(tmp_mouthpress_r));
  if (raw_mouthpress_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(35, this->_internal_mouthpress_r(), target);
  }

  // float mouthPucker = 36 [json_name = "mouthPucker"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpucker = this->_internal_mouthpucker();
  uint32_t raw_mouthpucker;
  memcpy(&raw_mouthpucker, &tmp_mouthpucker, sizeof(tmp_mouthpucker));
  if (raw_mouthpucker != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(36, this->_internal_mouthpucker(), target);
  }

  // float mouthRight = 37 [json_name = "mouthRight"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthright = this->_internal_mouthright();
  uint32_t raw_mouthright;
  memcpy(&raw_mouthright, &tmp_mouthright, sizeof(tmp_mouthright));
  if (raw_mouthright != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(37, this->_internal_mouthright(), target);
  }

  // float mouthRollLower = 38 [json_name = "mouthRollLower"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrolllower = this->_internal_mouthrolllower();
  uint32_t raw_mouthrolllower;
  memcpy(&raw_mouthrolllower, &tmp_mouthrolllower, sizeof(tmp_mouthrolllower));
  if (raw_mouthrolllower != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(38, this->_internal_mouthrolllower(), target);
  }

  // float mouthRollUpper = 39 [json_name = "mouthRollUpper"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrollupper = this->_internal_mouthrollupper();
  uint32_t raw_mouthrollupper;
  memcpy(&raw_mouthrollupper, &tmp_mouthrollupper, sizeof(tmp_mouthrollupper));
  if (raw_mouthrollupper != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(39, this->_internal_mouthrollupper(), target);
  }

  // float mouthShrugLower = 40 [json_name = "mouthShrugLower"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshruglower = this->_internal_mouthshruglower();
  uint32_t raw_mouthshruglower;
  memcpy(&raw_mouthshruglower, &tmp_mouthshruglower, sizeof(tmp_mouthshruglower));
  if (raw_mouthshruglower != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(40, this->_internal_mouthshruglower(), target);
  }

  // float mouthShrugUpper = 41 [json_name = "mouthShrugUpper"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshrugupper = this->_internal_mouthshrugupper();
  uint32_t raw_mouthshrugupper;
  memcpy(&raw_mouthshrugupper, &tmp_mouthshrugupper, sizeof(tmp_mouthshrugupper));
  if (raw_mouthshrugupper != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(41, this->_internal_mouthshrugupper(), target);
  }

  // float mouthSmile_L = 42 [json_name = "mouthSmileL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_l = this->_internal_mouthsmile_l();
  uint32_t raw_mouthsmile_l;
  memcpy(&raw_mouthsmile_l, &tmp_mouthsmile_l, sizeof(tmp_mouthsmile_l));
  if (raw_mouthsmile_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(42, this->_internal_mouthsmile_l(), target);
  }

  // float mouthSmile_R = 43 [json_name = "mouthSmileR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_r = this->_internal_mouthsmile_r();
  uint32_t raw_mouthsmile_r;
  memcpy(&raw_mouthsmile_r, &tmp_mouthsmile_r, sizeof(tmp_mouthsmile_r));
  if (raw_mouthsmile_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(43, this->_internal_mouthsmile_r(), target);
  }

  // float mouthStretch_L = 44 [json_name = "mouthStretchL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_l = this->_internal_mouthstretch_l();
  uint32_t raw_mouthstretch_l;
  memcpy(&raw_mouthstretch_l, &tmp_mouthstretch_l, sizeof(tmp_mouthstretch_l));
  if (raw_mouthstretch_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(44, this->_internal_mouthstretch_l(), target);
  }

  // float mouthStretch_R = 45 [json_name = "mouthStretchR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_r = this->_internal_mouthstretch_r();
  uint32_t raw_mouthstretch_r;
  memcpy(&raw_mouthstretch_r, &tmp_mouthstretch_r, sizeof(tmp_mouthstretch_r));
  if (raw_mouthstretch_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(45, this->_internal_mouthstretch_r(), target);
  }

  // float mouthUpperUp_L = 46 [json_name = "mouthUpperUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_l = this->_internal_mouthupperup_l();
  uint32_t raw_mouthupperup_l;
  memcpy(&raw_mouthupperup_l, &tmp_mouthupperup_l, sizeof(tmp_mouthupperup_l));
  if (raw_mouthupperup_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(46, this->_internal_mouthupperup_l(), target);
  }

  // float mouthUpperUp_R = 47 [json_name = "mouthUpperUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_r = this->_internal_mouthupperup_r();
  uint32_t raw_mouthupperup_r;
  memcpy(&raw_mouthupperup_r, &tmp_mouthupperup_r, sizeof(tmp_mouthupperup_r));
  if (raw_mouthupperup_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(47, this->_internal_mouthupperup_r(), target);
  }

  // float noseSneer_L = 48 [json_name = "noseSneerL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_l = this->_internal_nosesneer_l();
  uint32_t raw_nosesneer_l;
  memcpy(&raw_nosesneer_l, &tmp_nosesneer_l, sizeof(tmp_nosesneer_l));
  if (raw_nosesneer_l != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(48, this->_internal_nosesneer_l(), target);
  }

  // float noseSneer_R = 49 [json_name = "noseSneerR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_r = this->_internal_nosesneer_r();
  uint32_t raw_nosesneer_r;
  memcpy(&raw_nosesneer_r, &tmp_nosesneer_r, sizeof(tmp_nosesneer_r));
  if (raw_nosesneer_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(49, this->_internal_nosesneer_r(), target);
  }

  // float cheekPuff = 50 [json_name = "cheekPuff"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheekpuff = this->_internal_cheekpuff();
  uint32_t raw_cheekpuff;
  memcpy(&raw_cheekpuff, &tmp_cheekpuff, sizeof(tmp_cheekpuff));
  if (raw_cheekpuff != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(50, this->_internal_cheekpuff(), target);
  }

  // float jawForward = 51 [json_name = "jawForward"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawforward = this->_internal_jawforward();
  uint32_t raw_jawforward;
  memcpy(&raw_jawforward, &tmp_jawforward, sizeof(tmp_jawforward));
  if (raw_jawforward != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(51, this->_internal_jawforward(), target);
  }

  // float tongueOut = 52 [json_name = "tongueOut"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_tongueout = this->_internal_tongueout();
  uint32_t raw_tongueout;
  memcpy(&raw_tongueout, &tmp_tongueout, sizeof(tmp_tongueout));
  if (raw_tongueout != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(52, this->_internal_tongueout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BlendShapes)
  return target;
}

size_t BlendShapes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BlendShapes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float browDown_L = 1 [json_name = "browDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_l = this->_internal_browdown_l();
  uint32_t raw_browdown_l;
  memcpy(&raw_browdown_l, &tmp_browdown_l, sizeof(tmp_browdown_l));
  if (raw_browdown_l != 0) {
    total_size += 1 + 4;
  }

  // float browDown_R = 2 [json_name = "browDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_r = this->_internal_browdown_r();
  uint32_t raw_browdown_r;
  memcpy(&raw_browdown_r, &tmp_browdown_r, sizeof(tmp_browdown_r));
  if (raw_browdown_r != 0) {
    total_size += 1 + 4;
  }

  // float browInnerUp = 3 [json_name = "browInnerUp"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browinnerup = this->_internal_browinnerup();
  uint32_t raw_browinnerup;
  memcpy(&raw_browinnerup, &tmp_browinnerup, sizeof(tmp_browinnerup));
  if (raw_browinnerup != 0) {
    total_size += 1 + 4;
  }

  // float browOuterUp_L = 4 [json_name = "browOuterUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_l = this->_internal_browouterup_l();
  uint32_t raw_browouterup_l;
  memcpy(&raw_browouterup_l, &tmp_browouterup_l, sizeof(tmp_browouterup_l));
  if (raw_browouterup_l != 0) {
    total_size += 1 + 4;
  }

  // float browOuterUp_R = 5 [json_name = "browOuterUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_r = this->_internal_browouterup_r();
  uint32_t raw_browouterup_r;
  memcpy(&raw_browouterup_r, &tmp_browouterup_r, sizeof(tmp_browouterup_r));
  if (raw_browouterup_r != 0) {
    total_size += 1 + 4;
  }

  // float cheekSquint_L = 6 [json_name = "cheekSquintL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_l = this->_internal_cheeksquint_l();
  uint32_t raw_cheeksquint_l;
  memcpy(&raw_cheeksquint_l, &tmp_cheeksquint_l, sizeof(tmp_cheeksquint_l));
  if (raw_cheeksquint_l != 0) {
    total_size += 1 + 4;
  }

  // float cheekSquint_R = 7 [json_name = "cheekSquintR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_r = this->_internal_cheeksquint_r();
  uint32_t raw_cheeksquint_r;
  memcpy(&raw_cheeksquint_r, &tmp_cheeksquint_r, sizeof(tmp_cheeksquint_r));
  if (raw_cheeksquint_r != 0) {
    total_size += 1 + 4;
  }

  // float eyeBlink_L = 8 [json_name = "eyeBlinkL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_l = this->_internal_eyeblink_l();
  uint32_t raw_eyeblink_l;
  memcpy(&raw_eyeblink_l, &tmp_eyeblink_l, sizeof(tmp_eyeblink_l));
  if (raw_eyeblink_l != 0) {
    total_size += 1 + 4;
  }

  // float eyeBlink_R = 9 [json_name = "eyeBlinkR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_r = this->_internal_eyeblink_r();
  uint32_t raw_eyeblink_r;
  memcpy(&raw_eyeblink_r, &tmp_eyeblink_r, sizeof(tmp_eyeblink_r));
  if (raw_eyeblink_r != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookDown_L = 10 [json_name = "eyeLookDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_l = this->_internal_eyelookdown_l();
  uint32_t raw_eyelookdown_l;
  memcpy(&raw_eyelookdown_l, &tmp_eyelookdown_l, sizeof(tmp_eyelookdown_l));
  if (raw_eyelookdown_l != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookDown_R = 11 [json_name = "eyeLookDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_r = this->_internal_eyelookdown_r();
  uint32_t raw_eyelookdown_r;
  memcpy(&raw_eyelookdown_r, &tmp_eyelookdown_r, sizeof(tmp_eyelookdown_r));
  if (raw_eyelookdown_r != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookIn_L = 12 [json_name = "eyeLookInL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_l = this->_internal_eyelookin_l();
  uint32_t raw_eyelookin_l;
  memcpy(&raw_eyelookin_l, &tmp_eyelookin_l, sizeof(tmp_eyelookin_l));
  if (raw_eyelookin_l != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookIn_R = 13 [json_name = "eyeLookInR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_r = this->_internal_eyelookin_r();
  uint32_t raw_eyelookin_r;
  memcpy(&raw_eyelookin_r, &tmp_eyelookin_r, sizeof(tmp_eyelookin_r));
  if (raw_eyelookin_r != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookOut_L = 14 [json_name = "eyeLookOutL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_l = this->_internal_eyelookout_l();
  uint32_t raw_eyelookout_l;
  memcpy(&raw_eyelookout_l, &tmp_eyelookout_l, sizeof(tmp_eyelookout_l));
  if (raw_eyelookout_l != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookOut_R = 15 [json_name = "eyeLookOutR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_r = this->_internal_eyelookout_r();
  uint32_t raw_eyelookout_r;
  memcpy(&raw_eyelookout_r, &tmp_eyelookout_r, sizeof(tmp_eyelookout_r));
  if (raw_eyelookout_r != 0) {
    total_size += 1 + 4;
  }

  // float eyeLookUp_L = 16 [json_name = "eyeLookUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_l = this->_internal_eyelookup_l();
  uint32_t raw_eyelookup_l;
  memcpy(&raw_eyelookup_l, &tmp_eyelookup_l, sizeof(tmp_eyelookup_l));
  if (raw_eyelookup_l != 0) {
    total_size += 2 + 4;
  }

  // float eyeLookUp_R = 17 [json_name = "eyeLookUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_r = this->_internal_eyelookup_r();
  uint32_t raw_eyelookup_r;
  memcpy(&raw_eyelookup_r, &tmp_eyelookup_r, sizeof(tmp_eyelookup_r));
  if (raw_eyelookup_r != 0) {
    total_size += 2 + 4;
  }

  // float eyeSquint_L = 18 [json_name = "eyeSquintL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_l = this->_internal_eyesquint_l();
  uint32_t raw_eyesquint_l;
  memcpy(&raw_eyesquint_l, &tmp_eyesquint_l, sizeof(tmp_eyesquint_l));
  if (raw_eyesquint_l != 0) {
    total_size += 2 + 4;
  }

  // float eyeSquint_R = 19 [json_name = "eyeSquintR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_r = this->_internal_eyesquint_r();
  uint32_t raw_eyesquint_r;
  memcpy(&raw_eyesquint_r, &tmp_eyesquint_r, sizeof(tmp_eyesquint_r));
  if (raw_eyesquint_r != 0) {
    total_size += 2 + 4;
  }

  // float eyeWide_L = 20 [json_name = "eyeWideL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_l = this->_internal_eyewide_l();
  uint32_t raw_eyewide_l;
  memcpy(&raw_eyewide_l, &tmp_eyewide_l, sizeof(tmp_eyewide_l));
  if (raw_eyewide_l != 0) {
    total_size += 2 + 4;
  }

  // float eyeWide_R = 21 [json_name = "eyeWideR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_r = this->_internal_eyewide_r();
  uint32_t raw_eyewide_r;
  memcpy(&raw_eyewide_r, &tmp_eyewide_r, sizeof(tmp_eyewide_r));
  if (raw_eyewide_r != 0) {
    total_size += 2 + 4;
  }

  // float jawLeft = 22 [json_name = "jawLeft"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawleft = this->_internal_jawleft();
  uint32_t raw_jawleft;
  memcpy(&raw_jawleft, &tmp_jawleft, sizeof(tmp_jawleft));
  if (raw_jawleft != 0) {
    total_size += 2 + 4;
  }

  // float jawOpen = 23 [json_name = "jawOpen"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawopen = this->_internal_jawopen();
  uint32_t raw_jawopen;
  memcpy(&raw_jawopen, &tmp_jawopen, sizeof(tmp_jawopen));
  if (raw_jawopen != 0) {
    total_size += 2 + 4;
  }

  // float jawRight = 24 [json_name = "jawRight"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawright = this->_internal_jawright();
  uint32_t raw_jawright;
  memcpy(&raw_jawright, &tmp_jawright, sizeof(tmp_jawright));
  if (raw_jawright != 0) {
    total_size += 2 + 4;
  }

  // float mouthClose = 25 [json_name = "mouthClose"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthclose = this->_internal_mouthclose();
  uint32_t raw_mouthclose;
  memcpy(&raw_mouthclose, &tmp_mouthclose, sizeof(tmp_mouthclose));
  if (raw_mouthclose != 0) {
    total_size += 2 + 4;
  }

  // float mouthDimple_L = 26 [json_name = "mouthDimpleL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_l = this->_internal_mouthdimple_l();
  uint32_t raw_mouthdimple_l;
  memcpy(&raw_mouthdimple_l, &tmp_mouthdimple_l, sizeof(tmp_mouthdimple_l));
  if (raw_mouthdimple_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthDimple_R = 27 [json_name = "mouthDimpleR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_r = this->_internal_mouthdimple_r();
  uint32_t raw_mouthdimple_r;
  memcpy(&raw_mouthdimple_r, &tmp_mouthdimple_r, sizeof(tmp_mouthdimple_r));
  if (raw_mouthdimple_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthFrown_L = 28 [json_name = "mouthFrownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_l = this->_internal_mouthfrown_l();
  uint32_t raw_mouthfrown_l;
  memcpy(&raw_mouthfrown_l, &tmp_mouthfrown_l, sizeof(tmp_mouthfrown_l));
  if (raw_mouthfrown_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthFrown_R = 29 [json_name = "mouthFrownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_r = this->_internal_mouthfrown_r();
  uint32_t raw_mouthfrown_r;
  memcpy(&raw_mouthfrown_r, &tmp_mouthfrown_r, sizeof(tmp_mouthfrown_r));
  if (raw_mouthfrown_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthFunnel = 30 [json_name = "mouthFunnel"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfunnel = this->_internal_mouthfunnel();
  uint32_t raw_mouthfunnel;
  memcpy(&raw_mouthfunnel, &tmp_mouthfunnel, sizeof(tmp_mouthfunnel));
  if (raw_mouthfunnel != 0) {
    total_size += 2 + 4;
  }

  // float mouthLeft = 31 [json_name = "mouthLeft"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthleft = this->_internal_mouthleft();
  uint32_t raw_mouthleft;
  memcpy(&raw_mouthleft, &tmp_mouthleft, sizeof(tmp_mouthleft));
  if (raw_mouthleft != 0) {
    total_size += 2 + 4;
  }

  // float mouthLowerDown_L = 32 [json_name = "mouthLowerDownL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_l = this->_internal_mouthlowerdown_l();
  uint32_t raw_mouthlowerdown_l;
  memcpy(&raw_mouthlowerdown_l, &tmp_mouthlowerdown_l, sizeof(tmp_mouthlowerdown_l));
  if (raw_mouthlowerdown_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthLowerDown_R = 33 [json_name = "mouthLowerDownR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_r = this->_internal_mouthlowerdown_r();
  uint32_t raw_mouthlowerdown_r;
  memcpy(&raw_mouthlowerdown_r, &tmp_mouthlowerdown_r, sizeof(tmp_mouthlowerdown_r));
  if (raw_mouthlowerdown_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthPress_L = 34 [json_name = "mouthPressL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_l = this->_internal_mouthpress_l();
  uint32_t raw_mouthpress_l;
  memcpy(&raw_mouthpress_l, &tmp_mouthpress_l, sizeof(tmp_mouthpress_l));
  if (raw_mouthpress_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthPress_R = 35 [json_name = "mouthPressR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_r = this->_internal_mouthpress_r();
  uint32_t raw_mouthpress_r;
  memcpy(&raw_mouthpress_r, &tmp_mouthpress_r, sizeof(tmp_mouthpress_r));
  if (raw_mouthpress_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthPucker = 36 [json_name = "mouthPucker"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpucker = this->_internal_mouthpucker();
  uint32_t raw_mouthpucker;
  memcpy(&raw_mouthpucker, &tmp_mouthpucker, sizeof(tmp_mouthpucker));
  if (raw_mouthpucker != 0) {
    total_size += 2 + 4;
  }

  // float mouthRight = 37 [json_name = "mouthRight"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthright = this->_internal_mouthright();
  uint32_t raw_mouthright;
  memcpy(&raw_mouthright, &tmp_mouthright, sizeof(tmp_mouthright));
  if (raw_mouthright != 0) {
    total_size += 2 + 4;
  }

  // float mouthRollLower = 38 [json_name = "mouthRollLower"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrolllower = this->_internal_mouthrolllower();
  uint32_t raw_mouthrolllower;
  memcpy(&raw_mouthrolllower, &tmp_mouthrolllower, sizeof(tmp_mouthrolllower));
  if (raw_mouthrolllower != 0) {
    total_size += 2 + 4;
  }

  // float mouthRollUpper = 39 [json_name = "mouthRollUpper"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrollupper = this->_internal_mouthrollupper();
  uint32_t raw_mouthrollupper;
  memcpy(&raw_mouthrollupper, &tmp_mouthrollupper, sizeof(tmp_mouthrollupper));
  if (raw_mouthrollupper != 0) {
    total_size += 2 + 4;
  }

  // float mouthShrugLower = 40 [json_name = "mouthShrugLower"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshruglower = this->_internal_mouthshruglower();
  uint32_t raw_mouthshruglower;
  memcpy(&raw_mouthshruglower, &tmp_mouthshruglower, sizeof(tmp_mouthshruglower));
  if (raw_mouthshruglower != 0) {
    total_size += 2 + 4;
  }

  // float mouthShrugUpper = 41 [json_name = "mouthShrugUpper"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshrugupper = this->_internal_mouthshrugupper();
  uint32_t raw_mouthshrugupper;
  memcpy(&raw_mouthshrugupper, &tmp_mouthshrugupper, sizeof(tmp_mouthshrugupper));
  if (raw_mouthshrugupper != 0) {
    total_size += 2 + 4;
  }

  // float mouthSmile_L = 42 [json_name = "mouthSmileL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_l = this->_internal_mouthsmile_l();
  uint32_t raw_mouthsmile_l;
  memcpy(&raw_mouthsmile_l, &tmp_mouthsmile_l, sizeof(tmp_mouthsmile_l));
  if (raw_mouthsmile_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthSmile_R = 43 [json_name = "mouthSmileR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_r = this->_internal_mouthsmile_r();
  uint32_t raw_mouthsmile_r;
  memcpy(&raw_mouthsmile_r, &tmp_mouthsmile_r, sizeof(tmp_mouthsmile_r));
  if (raw_mouthsmile_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthStretch_L = 44 [json_name = "mouthStretchL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_l = this->_internal_mouthstretch_l();
  uint32_t raw_mouthstretch_l;
  memcpy(&raw_mouthstretch_l, &tmp_mouthstretch_l, sizeof(tmp_mouthstretch_l));
  if (raw_mouthstretch_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthStretch_R = 45 [json_name = "mouthStretchR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_r = this->_internal_mouthstretch_r();
  uint32_t raw_mouthstretch_r;
  memcpy(&raw_mouthstretch_r, &tmp_mouthstretch_r, sizeof(tmp_mouthstretch_r));
  if (raw_mouthstretch_r != 0) {
    total_size += 2 + 4;
  }

  // float mouthUpperUp_L = 46 [json_name = "mouthUpperUpL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_l = this->_internal_mouthupperup_l();
  uint32_t raw_mouthupperup_l;
  memcpy(&raw_mouthupperup_l, &tmp_mouthupperup_l, sizeof(tmp_mouthupperup_l));
  if (raw_mouthupperup_l != 0) {
    total_size += 2 + 4;
  }

  // float mouthUpperUp_R = 47 [json_name = "mouthUpperUpR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_r = this->_internal_mouthupperup_r();
  uint32_t raw_mouthupperup_r;
  memcpy(&raw_mouthupperup_r, &tmp_mouthupperup_r, sizeof(tmp_mouthupperup_r));
  if (raw_mouthupperup_r != 0) {
    total_size += 2 + 4;
  }

  // float noseSneer_L = 48 [json_name = "noseSneerL"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_l = this->_internal_nosesneer_l();
  uint32_t raw_nosesneer_l;
  memcpy(&raw_nosesneer_l, &tmp_nosesneer_l, sizeof(tmp_nosesneer_l));
  if (raw_nosesneer_l != 0) {
    total_size += 2 + 4;
  }

  // float noseSneer_R = 49 [json_name = "noseSneerR"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_r = this->_internal_nosesneer_r();
  uint32_t raw_nosesneer_r;
  memcpy(&raw_nosesneer_r, &tmp_nosesneer_r, sizeof(tmp_nosesneer_r));
  if (raw_nosesneer_r != 0) {
    total_size += 2 + 4;
  }

  // float cheekPuff = 50 [json_name = "cheekPuff"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheekpuff = this->_internal_cheekpuff();
  uint32_t raw_cheekpuff;
  memcpy(&raw_cheekpuff, &tmp_cheekpuff, sizeof(tmp_cheekpuff));
  if (raw_cheekpuff != 0) {
    total_size += 2 + 4;
  }

  // float jawForward = 51 [json_name = "jawForward"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawforward = this->_internal_jawforward();
  uint32_t raw_jawforward;
  memcpy(&raw_jawforward, &tmp_jawforward, sizeof(tmp_jawforward));
  if (raw_jawforward != 0) {
    total_size += 2 + 4;
  }

  // float tongueOut = 52 [json_name = "tongueOut"];
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_tongueout = this->_internal_tongueout();
  uint32_t raw_tongueout;
  memcpy(&raw_tongueout, &tmp_tongueout, sizeof(tmp_tongueout));
  if (raw_tongueout != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlendShapes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BlendShapes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlendShapes::GetClassData() const { return &_class_data_; }

void BlendShapes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BlendShapes *>(to)->MergeFrom(
      static_cast<const BlendShapes &>(from));
}


void BlendShapes::MergeFrom(const BlendShapes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:BlendShapes)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_l = from._internal_browdown_l();
  uint32_t raw_browdown_l;
  memcpy(&raw_browdown_l, &tmp_browdown_l, sizeof(tmp_browdown_l));
  if (raw_browdown_l != 0) {
    _internal_set_browdown_l(from._internal_browdown_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browdown_r = from._internal_browdown_r();
  uint32_t raw_browdown_r;
  memcpy(&raw_browdown_r, &tmp_browdown_r, sizeof(tmp_browdown_r));
  if (raw_browdown_r != 0) {
    _internal_set_browdown_r(from._internal_browdown_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browinnerup = from._internal_browinnerup();
  uint32_t raw_browinnerup;
  memcpy(&raw_browinnerup, &tmp_browinnerup, sizeof(tmp_browinnerup));
  if (raw_browinnerup != 0) {
    _internal_set_browinnerup(from._internal_browinnerup());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_l = from._internal_browouterup_l();
  uint32_t raw_browouterup_l;
  memcpy(&raw_browouterup_l, &tmp_browouterup_l, sizeof(tmp_browouterup_l));
  if (raw_browouterup_l != 0) {
    _internal_set_browouterup_l(from._internal_browouterup_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_browouterup_r = from._internal_browouterup_r();
  uint32_t raw_browouterup_r;
  memcpy(&raw_browouterup_r, &tmp_browouterup_r, sizeof(tmp_browouterup_r));
  if (raw_browouterup_r != 0) {
    _internal_set_browouterup_r(from._internal_browouterup_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_l = from._internal_cheeksquint_l();
  uint32_t raw_cheeksquint_l;
  memcpy(&raw_cheeksquint_l, &tmp_cheeksquint_l, sizeof(tmp_cheeksquint_l));
  if (raw_cheeksquint_l != 0) {
    _internal_set_cheeksquint_l(from._internal_cheeksquint_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheeksquint_r = from._internal_cheeksquint_r();
  uint32_t raw_cheeksquint_r;
  memcpy(&raw_cheeksquint_r, &tmp_cheeksquint_r, sizeof(tmp_cheeksquint_r));
  if (raw_cheeksquint_r != 0) {
    _internal_set_cheeksquint_r(from._internal_cheeksquint_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_l = from._internal_eyeblink_l();
  uint32_t raw_eyeblink_l;
  memcpy(&raw_eyeblink_l, &tmp_eyeblink_l, sizeof(tmp_eyeblink_l));
  if (raw_eyeblink_l != 0) {
    _internal_set_eyeblink_l(from._internal_eyeblink_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyeblink_r = from._internal_eyeblink_r();
  uint32_t raw_eyeblink_r;
  memcpy(&raw_eyeblink_r, &tmp_eyeblink_r, sizeof(tmp_eyeblink_r));
  if (raw_eyeblink_r != 0) {
    _internal_set_eyeblink_r(from._internal_eyeblink_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_l = from._internal_eyelookdown_l();
  uint32_t raw_eyelookdown_l;
  memcpy(&raw_eyelookdown_l, &tmp_eyelookdown_l, sizeof(tmp_eyelookdown_l));
  if (raw_eyelookdown_l != 0) {
    _internal_set_eyelookdown_l(from._internal_eyelookdown_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookdown_r = from._internal_eyelookdown_r();
  uint32_t raw_eyelookdown_r;
  memcpy(&raw_eyelookdown_r, &tmp_eyelookdown_r, sizeof(tmp_eyelookdown_r));
  if (raw_eyelookdown_r != 0) {
    _internal_set_eyelookdown_r(from._internal_eyelookdown_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_l = from._internal_eyelookin_l();
  uint32_t raw_eyelookin_l;
  memcpy(&raw_eyelookin_l, &tmp_eyelookin_l, sizeof(tmp_eyelookin_l));
  if (raw_eyelookin_l != 0) {
    _internal_set_eyelookin_l(from._internal_eyelookin_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookin_r = from._internal_eyelookin_r();
  uint32_t raw_eyelookin_r;
  memcpy(&raw_eyelookin_r, &tmp_eyelookin_r, sizeof(tmp_eyelookin_r));
  if (raw_eyelookin_r != 0) {
    _internal_set_eyelookin_r(from._internal_eyelookin_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_l = from._internal_eyelookout_l();
  uint32_t raw_eyelookout_l;
  memcpy(&raw_eyelookout_l, &tmp_eyelookout_l, sizeof(tmp_eyelookout_l));
  if (raw_eyelookout_l != 0) {
    _internal_set_eyelookout_l(from._internal_eyelookout_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookout_r = from._internal_eyelookout_r();
  uint32_t raw_eyelookout_r;
  memcpy(&raw_eyelookout_r, &tmp_eyelookout_r, sizeof(tmp_eyelookout_r));
  if (raw_eyelookout_r != 0) {
    _internal_set_eyelookout_r(from._internal_eyelookout_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_l = from._internal_eyelookup_l();
  uint32_t raw_eyelookup_l;
  memcpy(&raw_eyelookup_l, &tmp_eyelookup_l, sizeof(tmp_eyelookup_l));
  if (raw_eyelookup_l != 0) {
    _internal_set_eyelookup_l(from._internal_eyelookup_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyelookup_r = from._internal_eyelookup_r();
  uint32_t raw_eyelookup_r;
  memcpy(&raw_eyelookup_r, &tmp_eyelookup_r, sizeof(tmp_eyelookup_r));
  if (raw_eyelookup_r != 0) {
    _internal_set_eyelookup_r(from._internal_eyelookup_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_l = from._internal_eyesquint_l();
  uint32_t raw_eyesquint_l;
  memcpy(&raw_eyesquint_l, &tmp_eyesquint_l, sizeof(tmp_eyesquint_l));
  if (raw_eyesquint_l != 0) {
    _internal_set_eyesquint_l(from._internal_eyesquint_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyesquint_r = from._internal_eyesquint_r();
  uint32_t raw_eyesquint_r;
  memcpy(&raw_eyesquint_r, &tmp_eyesquint_r, sizeof(tmp_eyesquint_r));
  if (raw_eyesquint_r != 0) {
    _internal_set_eyesquint_r(from._internal_eyesquint_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_l = from._internal_eyewide_l();
  uint32_t raw_eyewide_l;
  memcpy(&raw_eyewide_l, &tmp_eyewide_l, sizeof(tmp_eyewide_l));
  if (raw_eyewide_l != 0) {
    _internal_set_eyewide_l(from._internal_eyewide_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_eyewide_r = from._internal_eyewide_r();
  uint32_t raw_eyewide_r;
  memcpy(&raw_eyewide_r, &tmp_eyewide_r, sizeof(tmp_eyewide_r));
  if (raw_eyewide_r != 0) {
    _internal_set_eyewide_r(from._internal_eyewide_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawleft = from._internal_jawleft();
  uint32_t raw_jawleft;
  memcpy(&raw_jawleft, &tmp_jawleft, sizeof(tmp_jawleft));
  if (raw_jawleft != 0) {
    _internal_set_jawleft(from._internal_jawleft());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawopen = from._internal_jawopen();
  uint32_t raw_jawopen;
  memcpy(&raw_jawopen, &tmp_jawopen, sizeof(tmp_jawopen));
  if (raw_jawopen != 0) {
    _internal_set_jawopen(from._internal_jawopen());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawright = from._internal_jawright();
  uint32_t raw_jawright;
  memcpy(&raw_jawright, &tmp_jawright, sizeof(tmp_jawright));
  if (raw_jawright != 0) {
    _internal_set_jawright(from._internal_jawright());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthclose = from._internal_mouthclose();
  uint32_t raw_mouthclose;
  memcpy(&raw_mouthclose, &tmp_mouthclose, sizeof(tmp_mouthclose));
  if (raw_mouthclose != 0) {
    _internal_set_mouthclose(from._internal_mouthclose());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_l = from._internal_mouthdimple_l();
  uint32_t raw_mouthdimple_l;
  memcpy(&raw_mouthdimple_l, &tmp_mouthdimple_l, sizeof(tmp_mouthdimple_l));
  if (raw_mouthdimple_l != 0) {
    _internal_set_mouthdimple_l(from._internal_mouthdimple_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthdimple_r = from._internal_mouthdimple_r();
  uint32_t raw_mouthdimple_r;
  memcpy(&raw_mouthdimple_r, &tmp_mouthdimple_r, sizeof(tmp_mouthdimple_r));
  if (raw_mouthdimple_r != 0) {
    _internal_set_mouthdimple_r(from._internal_mouthdimple_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_l = from._internal_mouthfrown_l();
  uint32_t raw_mouthfrown_l;
  memcpy(&raw_mouthfrown_l, &tmp_mouthfrown_l, sizeof(tmp_mouthfrown_l));
  if (raw_mouthfrown_l != 0) {
    _internal_set_mouthfrown_l(from._internal_mouthfrown_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfrown_r = from._internal_mouthfrown_r();
  uint32_t raw_mouthfrown_r;
  memcpy(&raw_mouthfrown_r, &tmp_mouthfrown_r, sizeof(tmp_mouthfrown_r));
  if (raw_mouthfrown_r != 0) {
    _internal_set_mouthfrown_r(from._internal_mouthfrown_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthfunnel = from._internal_mouthfunnel();
  uint32_t raw_mouthfunnel;
  memcpy(&raw_mouthfunnel, &tmp_mouthfunnel, sizeof(tmp_mouthfunnel));
  if (raw_mouthfunnel != 0) {
    _internal_set_mouthfunnel(from._internal_mouthfunnel());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthleft = from._internal_mouthleft();
  uint32_t raw_mouthleft;
  memcpy(&raw_mouthleft, &tmp_mouthleft, sizeof(tmp_mouthleft));
  if (raw_mouthleft != 0) {
    _internal_set_mouthleft(from._internal_mouthleft());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_l = from._internal_mouthlowerdown_l();
  uint32_t raw_mouthlowerdown_l;
  memcpy(&raw_mouthlowerdown_l, &tmp_mouthlowerdown_l, sizeof(tmp_mouthlowerdown_l));
  if (raw_mouthlowerdown_l != 0) {
    _internal_set_mouthlowerdown_l(from._internal_mouthlowerdown_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthlowerdown_r = from._internal_mouthlowerdown_r();
  uint32_t raw_mouthlowerdown_r;
  memcpy(&raw_mouthlowerdown_r, &tmp_mouthlowerdown_r, sizeof(tmp_mouthlowerdown_r));
  if (raw_mouthlowerdown_r != 0) {
    _internal_set_mouthlowerdown_r(from._internal_mouthlowerdown_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_l = from._internal_mouthpress_l();
  uint32_t raw_mouthpress_l;
  memcpy(&raw_mouthpress_l, &tmp_mouthpress_l, sizeof(tmp_mouthpress_l));
  if (raw_mouthpress_l != 0) {
    _internal_set_mouthpress_l(from._internal_mouthpress_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpress_r = from._internal_mouthpress_r();
  uint32_t raw_mouthpress_r;
  memcpy(&raw_mouthpress_r, &tmp_mouthpress_r, sizeof(tmp_mouthpress_r));
  if (raw_mouthpress_r != 0) {
    _internal_set_mouthpress_r(from._internal_mouthpress_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthpucker = from._internal_mouthpucker();
  uint32_t raw_mouthpucker;
  memcpy(&raw_mouthpucker, &tmp_mouthpucker, sizeof(tmp_mouthpucker));
  if (raw_mouthpucker != 0) {
    _internal_set_mouthpucker(from._internal_mouthpucker());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthright = from._internal_mouthright();
  uint32_t raw_mouthright;
  memcpy(&raw_mouthright, &tmp_mouthright, sizeof(tmp_mouthright));
  if (raw_mouthright != 0) {
    _internal_set_mouthright(from._internal_mouthright());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrolllower = from._internal_mouthrolllower();
  uint32_t raw_mouthrolllower;
  memcpy(&raw_mouthrolllower, &tmp_mouthrolllower, sizeof(tmp_mouthrolllower));
  if (raw_mouthrolllower != 0) {
    _internal_set_mouthrolllower(from._internal_mouthrolllower());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthrollupper = from._internal_mouthrollupper();
  uint32_t raw_mouthrollupper;
  memcpy(&raw_mouthrollupper, &tmp_mouthrollupper, sizeof(tmp_mouthrollupper));
  if (raw_mouthrollupper != 0) {
    _internal_set_mouthrollupper(from._internal_mouthrollupper());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshruglower = from._internal_mouthshruglower();
  uint32_t raw_mouthshruglower;
  memcpy(&raw_mouthshruglower, &tmp_mouthshruglower, sizeof(tmp_mouthshruglower));
  if (raw_mouthshruglower != 0) {
    _internal_set_mouthshruglower(from._internal_mouthshruglower());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthshrugupper = from._internal_mouthshrugupper();
  uint32_t raw_mouthshrugupper;
  memcpy(&raw_mouthshrugupper, &tmp_mouthshrugupper, sizeof(tmp_mouthshrugupper));
  if (raw_mouthshrugupper != 0) {
    _internal_set_mouthshrugupper(from._internal_mouthshrugupper());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_l = from._internal_mouthsmile_l();
  uint32_t raw_mouthsmile_l;
  memcpy(&raw_mouthsmile_l, &tmp_mouthsmile_l, sizeof(tmp_mouthsmile_l));
  if (raw_mouthsmile_l != 0) {
    _internal_set_mouthsmile_l(from._internal_mouthsmile_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthsmile_r = from._internal_mouthsmile_r();
  uint32_t raw_mouthsmile_r;
  memcpy(&raw_mouthsmile_r, &tmp_mouthsmile_r, sizeof(tmp_mouthsmile_r));
  if (raw_mouthsmile_r != 0) {
    _internal_set_mouthsmile_r(from._internal_mouthsmile_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_l = from._internal_mouthstretch_l();
  uint32_t raw_mouthstretch_l;
  memcpy(&raw_mouthstretch_l, &tmp_mouthstretch_l, sizeof(tmp_mouthstretch_l));
  if (raw_mouthstretch_l != 0) {
    _internal_set_mouthstretch_l(from._internal_mouthstretch_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthstretch_r = from._internal_mouthstretch_r();
  uint32_t raw_mouthstretch_r;
  memcpy(&raw_mouthstretch_r, &tmp_mouthstretch_r, sizeof(tmp_mouthstretch_r));
  if (raw_mouthstretch_r != 0) {
    _internal_set_mouthstretch_r(from._internal_mouthstretch_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_l = from._internal_mouthupperup_l();
  uint32_t raw_mouthupperup_l;
  memcpy(&raw_mouthupperup_l, &tmp_mouthupperup_l, sizeof(tmp_mouthupperup_l));
  if (raw_mouthupperup_l != 0) {
    _internal_set_mouthupperup_l(from._internal_mouthupperup_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_mouthupperup_r = from._internal_mouthupperup_r();
  uint32_t raw_mouthupperup_r;
  memcpy(&raw_mouthupperup_r, &tmp_mouthupperup_r, sizeof(tmp_mouthupperup_r));
  if (raw_mouthupperup_r != 0) {
    _internal_set_mouthupperup_r(from._internal_mouthupperup_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_l = from._internal_nosesneer_l();
  uint32_t raw_nosesneer_l;
  memcpy(&raw_nosesneer_l, &tmp_nosesneer_l, sizeof(tmp_nosesneer_l));
  if (raw_nosesneer_l != 0) {
    _internal_set_nosesneer_l(from._internal_nosesneer_l());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_nosesneer_r = from._internal_nosesneer_r();
  uint32_t raw_nosesneer_r;
  memcpy(&raw_nosesneer_r, &tmp_nosesneer_r, sizeof(tmp_nosesneer_r));
  if (raw_nosesneer_r != 0) {
    _internal_set_nosesneer_r(from._internal_nosesneer_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cheekpuff = from._internal_cheekpuff();
  uint32_t raw_cheekpuff;
  memcpy(&raw_cheekpuff, &tmp_cheekpuff, sizeof(tmp_cheekpuff));
  if (raw_cheekpuff != 0) {
    _internal_set_cheekpuff(from._internal_cheekpuff());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_jawforward = from._internal_jawforward();
  uint32_t raw_jawforward;
  memcpy(&raw_jawforward, &tmp_jawforward, sizeof(tmp_jawforward));
  if (raw_jawforward != 0) {
    _internal_set_jawforward(from._internal_jawforward());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_tongueout = from._internal_tongueout();
  uint32_t raw_tongueout;
  memcpy(&raw_tongueout, &tmp_tongueout, sizeof(tmp_tongueout));
  if (raw_tongueout != 0) {
    _internal_set_tongueout(from._internal_tongueout());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlendShapes::CopyFrom(const BlendShapes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BlendShapes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlendShapes::IsInitialized() const {
  return true;
}

void BlendShapes::InternalSwap(BlendShapes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BlendShapes, tongueout_)
      + sizeof(BlendShapes::tongueout_)
      - PROTOBUF_FIELD_OFFSET(BlendShapes, browdown_l_)>(
          reinterpret_cast<char*>(&browdown_l_),
          reinterpret_cast<char*>(&other->browdown_l_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BlendShapes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_avatar_5fmessage_2eproto_getter, &descriptor_table_avatar_5fmessage_2eproto_once,
      file_level_metadata_avatar_5fmessage_2eproto[1]);
}

// ===================================================================

class Rotation::_Internal {
 public:
  using HasBits = decltype(std::declval<Rotation>()._has_bits_);
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_roll(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yaw(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Rotation::Rotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Rotation)
}
Rotation::Rotation(const Rotation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&pitch_, &from.pitch_,
    static_cast<size_t>(reinterpret_cast<char*>(&yaw_) -
    reinterpret_cast<char*>(&pitch_)) + sizeof(yaw_));
  // @@protoc_insertion_point(copy_constructor:Rotation)
}

inline void Rotation::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&pitch_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&yaw_) -
    reinterpret_cast<char*>(&pitch_)) + sizeof(yaw_));
}

Rotation::~Rotation() {
  // @@protoc_insertion_point(destructor:Rotation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Rotation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Rotation::ArenaDtor(void* object) {
  Rotation* _this = reinterpret_cast< Rotation* >(object);
  (void)_this;
}
void Rotation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Rotation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Rotation::Clear() {
// @@protoc_insertion_point(message_clear_start:Rotation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&pitch_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&yaw_) -
        reinterpret_cast<char*>(&pitch_)) + sizeof(yaw_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Rotation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float pitch = 1 [json_name = "pitch"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_pitch(&has_bits);
          pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float roll = 2 [json_name = "roll"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_roll(&has_bits);
          roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float yaw = 3 [json_name = "yaw"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_yaw(&has_bits);
          yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rotation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Rotation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float pitch = 1 [json_name = "pitch"];
  if (_internal_has_pitch()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_pitch(), target);
  }

  // optional float roll = 2 [json_name = "roll"];
  if (_internal_has_roll()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_roll(), target);
  }

  // optional float yaw = 3 [json_name = "yaw"];
  if (_internal_has_yaw()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Rotation)
  return target;
}

size_t Rotation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Rotation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float pitch = 1 [json_name = "pitch"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float roll = 2 [json_name = "roll"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float yaw = 3 [json_name = "yaw"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Rotation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Rotation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Rotation::GetClassData() const { return &_class_data_; }

void Rotation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Rotation *>(to)->MergeFrom(
      static_cast<const Rotation &>(from));
}


void Rotation::MergeFrom(const Rotation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Rotation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      pitch_ = from.pitch_;
    }
    if (cached_has_bits & 0x00000002u) {
      roll_ = from.roll_;
    }
    if (cached_has_bits & 0x00000004u) {
      yaw_ = from.yaw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Rotation::CopyFrom(const Rotation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Rotation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rotation::IsInitialized() const {
  return true;
}

void Rotation::InternalSwap(Rotation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rotation, yaw_)
      + sizeof(Rotation::yaw_)
      - PROTOBUF_FIELD_OFFSET(Rotation, pitch_)>(
          reinterpret_cast<char*>(&pitch_),
          reinterpret_cast<char*>(&other->pitch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Rotation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_avatar_5fmessage_2eproto_getter, &descriptor_table_avatar_5fmessage_2eproto_once,
      file_level_metadata_avatar_5fmessage_2eproto[2]);
}

// ===================================================================

class Transform::_Internal {
 public:
  using HasBits = decltype(std::declval<Transform>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Transform::Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Transform)
}
Transform::Transform(const Transform& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:Transform)
}

inline void Transform::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Transform::~Transform() {
  // @@protoc_insertion_point(destructor:Transform)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Transform::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Transform::ArenaDtor(void* object) {
  Transform* _this = reinterpret_cast< Transform* >(object);
  (void)_this;
}
void Transform::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Transform::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Transform::Clear() {
// @@protoc_insertion_point(message_clear_start:Transform)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Transform::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1 [json_name = "x"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2 [json_name = "y"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3 [json_name = "z"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Transform::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Transform)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1 [json_name = "x"];
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2 [json_name = "y"];
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3 [json_name = "z"];
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Transform)
  return target;
}

size_t Transform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Transform)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1 [json_name = "x"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2 [json_name = "y"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3 [json_name = "z"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Transform::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Transform::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Transform::GetClassData() const { return &_class_data_; }

void Transform::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Transform *>(to)->MergeFrom(
      static_cast<const Transform &>(from));
}


void Transform::MergeFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Transform)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Transform::CopyFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transform::IsInitialized() const {
  return true;
}

void Transform::InternalSwap(Transform* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Transform, z_)
      + sizeof(Transform::z_)
      - PROTOBUF_FIELD_OFFSET(Transform, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Transform::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_avatar_5fmessage_2eproto_getter, &descriptor_table_avatar_5fmessage_2eproto_once,
      file_level_metadata_avatar_5fmessage_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AvatarPredictionMessage* Arena::CreateMaybeMessage< ::AvatarPredictionMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AvatarPredictionMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::BlendShapes* Arena::CreateMaybeMessage< ::BlendShapes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BlendShapes >(arena);
}
template<> PROTOBUF_NOINLINE ::Rotation* Arena::CreateMaybeMessage< ::Rotation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Rotation >(arena);
}
template<> PROTOBUF_NOINLINE ::Transform* Arena::CreateMaybeMessage< ::Transform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Transform >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
